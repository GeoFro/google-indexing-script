{"version":3,"sources":["../src/shared/utils.ts"],"names":["batch","task","items","batchSize","onBatchComplete","chunks","createChunks","i","fetchRetry","url","options","retries","response","body","err","init_utils","__esmMin","arr","size","_"],"mappings":"wCAgBA,eAAsBA,EACpBC,EACAC,EACAC,EACAC,EACA,CACA,IAAMC,EAASC,EAAaJ,EAAOC,CAAS,EAC5C,QAASI,EAAI,EAAGA,EAAIF,EAAO,OAAQE,IACjC,MAAM,QAAQ,IAAIF,EAAOE,CAAC,EAAE,IAAIN,CAAI,CAAC,EACrCG,EAAgBG,EAAGF,EAAO,MAAM,CAEpC,CAUA,eAAsBG,EAAWC,EAAaC,EAAsBC,EAAkB,EAAG,CACvF,GAAI,CACF,IAAMC,EAAW,MAAM,MAAMH,EAAKC,CAAO,EACzC,GAAIE,EAAS,QAAU,IAAK,CAC1B,IAAMC,EAAO,MAAMD,EAAS,KAAK,EACjC,MAAM,IAAI,MAAM,qBAAqBA,EAAS,MAAM;AAAA,EAAKC,CAAI,EAAE,CACjE,CACA,OAAOD,CACT,OAASE,EAAK,CACZ,GAAIH,GAAW,EACb,MAAMG,EAER,OAAON,EAAWC,EAAKC,EAASC,EAAU,CAAC,CAC7C,CACF,CAnDA,IAMML,EANNS,EAAAC,EAAA,KAMMV,EAAe,CAACW,EAAYC,IAChC,MAAM,KAAK,CAAE,OAAQ,KAAK,KAAKD,EAAI,OAASC,CAAI,CAAE,EAAG,CAACC,EAAGZ,IAAMU,EAAI,MAAMV,EAAIW,EAAMX,EAAIW,EAAOA,CAAI,CAAC","sourcesContent":["/**\n * Creates an array of chunks from the given array with a specified size.\n * @param arr The array to be chunked.\n * @param size The size of each chunk.\n * @returns An array of chunks.\n */\nconst createChunks = (arr: any[], size: number) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (_, i) => arr.slice(i * size, i * size + size));\n\n/**\n * Executes tasks on items in batches and invokes a callback upon completion of each batch.\n * @param task The task function to be executed on each item.\n * @param items The array of items on which the task is to be executed.\n * @param batchSize The size of each batch.\n * @param onBatchComplete The callback function invoked upon completion of each batch.\n */\nexport async function batch(\n  task: (url: string) => void,\n  items: string[],\n  batchSize: number,\n  onBatchComplete: (batchIndex: number, batchCount: number) => void\n) {\n  const chunks = createChunks(items, batchSize);\n  for (let i = 0; i < chunks.length; i++) {\n    await Promise.all(chunks[i].map(task));\n    onBatchComplete(i, chunks.length);\n  }\n}\n\n/**\n * Fetches a resource from a URL with retry logic.\n * @param url The URL of the resource to fetch.\n * @param options The options for the fetch request.\n * @param retries The number of retry attempts (default is 5).\n * @returns A Promise resolving to the fetched response.\n * @throws Error when retries are exhausted or server error occurs.\n */\nexport async function fetchRetry(url: string, options: RequestInit, retries: number = 5) {\n  try {\n    const response = await fetch(url, options);\n    if (response.status >= 500) {\n      const body = await response.text();\n      throw new Error(`Server error code ${response.status}\\n${body}`);\n    }\n    return response;\n  } catch (err) {\n    if (retries <= 0) {\n      throw err;\n    }\n    return fetchRetry(url, options, retries - 1);\n  }\n}\n"]}