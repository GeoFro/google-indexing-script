{"version":3,"sources":["../src/shared/index.ts","../src/index.ts","../src/shared/gsc.ts"],"names":["init_shared","__esmMin","init_auth","init_gsc","init_sitemap","init_types","init_utils","readFileSync","existsSync","mkdirSync","writeFileSync","path","CACHE_TIMEOUT","QUOTA","index","init_src","input","options","accessToken","getAccessToken","siteUrl","convertToSiteUrl","cachePath","convertToFilePath","checkSiteUrl","pages","sitemaps","pagesFromSitemaps","getSitemapPages","checkCustomUrls","statusPerUrl","pagesPerStatus","indexableStatuses","shouldRecheck","status","lastCheckedAt","shouldIndexIt","isOld","batch","url","result","getPageIndexingStatus","batchIndex","batchCount","getEmojiForStatus","indexablePages","getPublishMetadata","requestIndexing","convertToSCDomain","httpUrl","convertToHTTP","domain","convertToHTTPS","getSites","sitesResponse","fetchRetry","sitesBody","x","sites","formattedUrls","formattedUrl","urls","protocol","inspectionUrl","response","error","RPM_WATING_TIME","resolve"],"mappings":"oOAAA,IAAAA,EAAAC,EAAA,KAAAC,IACAC,IACAC,IACAC,IACAC,MCUA,OAAS,gBAAAC,EAAc,cAAAC,EAAY,aAAAC,EAAW,iBAAAC,MAAqB,KACnE,OAAOC,MAAU,OAfjB,IAiBMC,EACOC,EAuBAC,GAzCbC,EAAAd,EAAA,KAAAC,IACAC,IAUAC,IACAC,IACAC,IA0KAN,IAtKMY,EAAgB,IAAO,GAAK,GAAK,GAAK,GAC/BC,EAAQ,CACnB,IAAK,CACH,QAAS,EACT,YAAa,GACf,CACF,EAkBaC,GAAQ,MAAOE,EAAgB,QAAQ,KAAK,CAAC,EAAGC,EAAwB,CAAC,IAAM,CAC1F,GAAI,CAACD,EACH,MAAM,IAAI,MAAM,4DAA4D,EAGzEC,EAAQ,eACXA,EAAQ,aAAe,QAAQ,IAAI,kBAEhCA,EAAQ,cACXA,EAAQ,YAAc,QAAQ,IAAI,iBAE/BA,EAAQ,OACXA,EAAQ,KAAO,QAAQ,IAAI,UAExBA,EAAQ,OACXA,EAAQ,KAAO,QAAQ,IAAI,SAAW,QAAQ,IAAI,SAAS,MAAM,GAAG,EAAI,QAErEA,EAAQ,QACXA,EAAQ,MAAQ,CACd,SAAU,QAAQ,IAAI,sBAAwB,MAChD,GAGF,IAAMC,EAAc,MAAMC,EAAeF,EAAQ,aAAcA,EAAQ,YAAaA,EAAQ,IAAI,EAC5FG,EAAUC,EAAiBL,CAAK,EACpC,QAAQ,IAAI,8BAAuBI,CAAO,EAAE,EAC5C,IAAME,EAAYX,EAAK,KAAK,SAAU,GAAGY,EAAkBH,CAAO,CAAC,OAAO,EAE1E,GAAI,CAACF,EACH,MAAM,IAAI,MAAM,qEAAqE,EAGvFE,EAAU,MAAMI,EAAaN,EAAaE,CAAO,EAEjD,IAAIK,EAAQR,EAAQ,MAAQ,CAAC,EAC7B,GAAIQ,EAAM,SAAW,EAAG,CACtB,QAAQ,IAAI,0CAAmC,EAC/C,GAAM,CAACC,EAAUC,CAAiB,EAAI,MAAMC,EAAgBV,EAAaE,CAAO,EAEhF,GAAIM,EAAS,SAAW,EACtB,MAAM,IAAI,MAAM,qEAAqE,EAGvFD,EAAQE,EAER,QAAQ,IAAI,mBAAYF,EAAM,MAAM,YAAYC,EAAS,MAAM,UAAU,CAC3E,MACED,EAAQI,EAAgBT,EAASK,CAAK,EACtC,QAAQ,IAAI,mBAAYA,EAAM,MAAM,4BAA4B,EAGlE,IAAMK,EAA0EtB,EAAWc,CAAS,EAChG,KAAK,MAAMf,EAAae,EAAW,MAAM,CAAC,EAC1C,CAAC,EACCS,EAA2C,CAC9C,wBAA6B,CAAC,EAC9B,4CAA+C,CAAC,EAChD,kCAAoC,CAAC,EACrC,qCAAuC,CAAC,EACxC,qBAA0B,CAAC,EAC3B,2BAA8B,CAAC,EAC/B,YAAqB,CAAC,EACtB,UAAmB,CAAC,EACpB,MAAe,CAAC,CACnB,EAEMC,EAAoB,oIAO1B,EAEMC,EAAgB,CAACC,EAAgBC,IAA0B,CAC/D,IAAMC,EAAgBJ,EAAkB,SAASE,CAAM,EACjDG,EAAQ,IAAI,KAAKF,CAAa,EAAI,IAAI,KAAK,KAAK,IAAI,EAAIvB,CAAa,EAC3E,OAAOwB,GAAiBC,CAC1B,EAEA,MAAMC,EACJ,MAAOC,GAAQ,CACb,IAAIC,EAASV,EAAaS,CAAG,GACzB,CAACC,GAAUP,EAAcO,EAAO,OAAQA,EAAO,aAAa,KAE9DA,EAAS,CAAE,OADI,MAAMC,EAAsBvB,EAAaE,EAASmB,CAAG,EACjD,cAAe,IAAI,KAAK,EAAE,YAAY,CAAE,EAC3DT,EAAaS,CAAG,EAAIC,GAGtBT,EAAeS,EAAO,MAAM,EAAIT,EAAeS,EAAO,MAAM,EAAI,CAAC,GAAGT,EAAeS,EAAO,MAAM,EAAGD,CAAG,EAAI,CAACA,CAAG,CAChH,EACAd,EACA,GACA,CAACiB,EAAYC,IAAe,CAC1B,QAAQ,IAAI,mBAAYD,EAAa,CAAC,OAAOC,CAAU,WAAW,CACpE,CACF,EAEA,QAAQ,IAAI,EAAE,EACd,QAAQ,IAAI,4CAAqClB,EAAM,MAAM,SAAS,EACtEhB,EAAU,SAAU,CAAE,UAAW,EAAK,CAAC,EACvCC,EAAcY,EAAW,KAAK,UAAUQ,EAAc,KAAM,CAAC,CAAC,EAE9D,QAAWI,KAAU,OAAO,KAAKH,CAAc,EAAG,CAChD,IAAMN,EAAQM,EAAeG,CAAgB,EACzCT,EAAM,SAAW,GACrB,QAAQ,IAAI,UAAKmB,EAAkBV,CAAgB,CAAC,IAAIA,CAAM,KAAKT,EAAM,MAAM,QAAQ,CACzF,CACA,QAAQ,IAAI,EAAE,EAEd,IAAMoB,EAAiB,OAAO,QAAQd,CAAc,EAAE,QAAQ,CAAC,CAACG,EAAQT,CAAK,IAC3EO,EAAkB,SAASE,CAAgB,EAAIT,EAAQ,CAAC,CAC1D,EAEIoB,EAAe,SAAW,EAC5B,QAAQ,IAAI,+EAA0E,GAEtF,QAAQ,IAAI,gBAAWA,EAAe,MAAM,6BAA6B,EACzEA,EAAe,QAASN,GAAQ,QAAQ,IAAI,UAAKA,CAAG,EAAE,CAAC,GAEzD,QAAQ,IAAI,EAAE,EAEd,QAAWA,KAAOM,EAAgB,CAChC,QAAQ,IAAI,6BAAsBN,CAAG,EAAE,EACvC,IAAML,EAAS,MAAMY,EAAmB5B,EAAaqB,EAAK,CACxD,mBAAoBtB,EAAQ,MAAM,SAAWJ,EAAM,IAAI,QAAU,CACnE,CAAC,EACGqB,IAAW,KACb,MAAMa,EAAgB7B,EAAaqB,CAAG,EACtC,QAAQ,IAAI,6FAAsF,GACzFL,EAAS,KAClB,QAAQ,IAAI,mGAA4F,EAE1G,QAAQ,IAAI,EAAE,CAChB,CAEA,QAAQ,IAAI,qBAAc,EAC1B,QAAQ,IAAI,kEAA2D,EACvE,QAAQ,IAAI,EAAE,CAChB,IC3KO,SAASb,EAAiBL,EAAe,CAC9C,OAAIA,EAAM,WAAW,SAAS,GAAKA,EAAM,WAAW,UAAU,EACrDA,EAAM,SAAS,GAAG,EAAIA,EAAQ,GAAGA,CAAK,IAExC,aAAaA,CAAK,EAC3B,CAOO,SAASO,EAAkBZ,EAAc,CAC9C,OAAOA,EAAK,QAAQ,UAAW,OAAO,EAAE,QAAQ,WAAY,QAAQ,EAAE,WAAW,IAAK,GAAG,CAC3F,CAOO,SAASqC,EAAkBC,EAAiB,CACjD,MAAO,aAAaA,EAAQ,QAAQ,UAAW,EAAE,EAAE,QAAQ,WAAY,EAAE,EAAE,QAAQ,IAAK,EAAE,CAAC,EAC7F,CAOO,SAASC,EAAcC,EAAgB,CAC5C,MAAO,UAAUA,CAAM,GACzB,CAOO,SAASC,EAAeD,EAAgB,CAC7C,MAAO,WAAWA,CAAM,GAC1B,CAOA,eAAsBE,EAASnC,EAAqB,CAClD,IAAMoC,EAAgB,MAAMC,EAAW,iDAAkD,CACvF,QAAS,CACP,eAAgB,mBAChB,cAAe,UAAUrC,CAAW,EACtC,CACF,CAAC,EAED,GAAIoC,EAAc,SAAW,IAC3B,eAAQ,MAAM,kEAA2D,EAClE,CAAC,EAGV,IAAME,EAAoD,MAAMF,EAAc,KAAK,EAEnF,OAAKE,EAAU,UAKRA,EAAU,UAAU,IAAKC,GAAMA,EAAE,OAAO,GAJ7C,QAAQ,MAAM,yEAAoE,EAC3E,CAAC,EAIZ,CASA,eAAsBjC,EAAaN,EAAqBE,EAAiB,CACvE,IAAMsC,EAAQ,MAAML,EAASnC,CAAW,EACpCyC,EAA0B,CAAC,EAG/B,GAAIvC,EAAQ,WAAW,UAAU,EAC/BuC,EAAc,KAAKvC,CAAO,EAC1BuC,EAAc,KAAKT,EAAc9B,EAAQ,QAAQ,WAAY,EAAE,CAAC,CAAC,EACjEuC,EAAc,KAAKX,EAAkB5B,CAAO,CAAC,UACpCA,EAAQ,WAAW,SAAS,EACrCuC,EAAc,KAAKvC,CAAO,EAC1BuC,EAAc,KAAKP,EAAehC,EAAQ,QAAQ,UAAW,EAAE,CAAC,CAAC,EACjEuC,EAAc,KAAKX,EAAkB5B,CAAO,CAAC,UACpCA,EAAQ,WAAW,YAAY,EACxCuC,EAAc,KAAKvC,CAAO,EAC1BuC,EAAc,KAAKT,EAAc9B,EAAQ,QAAQ,aAAc,EAAE,CAAC,CAAC,EACnEuC,EAAc,KAAKP,EAAehC,EAAQ,QAAQ,aAAc,EAAE,CAAC,CAAC,MAEpE,OAAM,IAAI,MAAM,0BAA0B,EAI5C,QAAWwC,KAAgBD,EACzB,GAAID,EAAM,SAASE,CAAY,EAC7B,OAAOA,EAKX,MAAM,IAAI,MAAM,wDAAwD,CAC1E,CAQO,SAAS/B,EAAgBT,EAAiByC,EAAgB,CAC/D,IAAMC,EAAW1C,EAAQ,WAAW,SAAS,EAAI,UAAY,WACvD+B,EAAS/B,EAAQ,QAAQ,WAAY,EAAE,EAAE,QAAQ,UAAW,EAAE,EAAE,QAAQ,aAAc,EAAE,EAkB9F,OAjBgCyC,EAAK,IAAKtB,IACxCA,EAAMA,EAAI,KAAK,EACXA,EAAI,WAAW,GAAG,EAEb,GAAGuB,CAAQ,GAAGX,CAAM,GAAGZ,CAAG,GACxBA,EAAI,WAAW,SAAS,GAAKA,EAAI,WAAW,UAAU,EAExDA,EACEA,EAAI,WAAWY,CAAM,EAEvB,GAAGW,CAAQ,GAAGvB,CAAG,GAGjB,GAAGuB,CAAQ,GAAGX,CAAM,IAAIZ,CAAG,GAErC,CAGH,CASA,eAAsBE,EACpBvB,EACAE,EACA2C,EACiB,CACjB,GAAI,CACF,IAAMC,EAAW,MAAMT,EAAW,sEAAuE,CACvG,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,cAAe,UAAUrC,CAAW,EACtC,EACA,KAAM,KAAK,UAAU,CACnB,cAAA6C,EACA,QAAA3C,CACF,CAAC,CACH,CAAC,EAED,OAAI4C,EAAS,SAAW,KACtB,QAAQ,MAAM,kEAA2D,EACzE,QAAQ,MAAM,MAAMA,EAAS,KAAK,CAAC,eAKjCA,EAAS,QAAU,IACjBA,EAAS,SAAW,mBAGtB,QAAQ,MAAM,uCAAkC,EAChD,QAAQ,MAAM,iBAAiBA,EAAS,MAAM,EAAE,EAChD,QAAQ,MAAM,MAAMA,EAAS,KAAK,CAAC,YAM1B,MAAMA,EAAS,KAAK,GACrB,iBAAiB,kBAAkB,aACjD,OAASC,EAAO,CACd,cAAQ,MAAM,uCAAkC,EAChD,QAAQ,MAAM,cAAcA,CAAK,EAAE,EAC7BA,CACR,CACF,CAOO,SAASrB,EAAkBV,EAAgB,CAChD,OAAQA,EAAQ,CACd,4BACE,MAAO,SACT,gDACE,MAAO,YACT,sCACA,yCACE,MAAO,YACT,yBACE,MAAO,YACT,+BACE,MAAO,SACT,kBACE,MAAO,YACT,QACE,MAAO,QACX,CACF,CAUA,eAAsBY,EAAmB5B,EAAqBqB,EAAatB,EAA0C,CACnH,IAAM+C,EAAW,MAAMT,EACrB,oEAAoE,mBAAmBhB,CAAG,CAAC,GAC3F,CACE,OAAQ,MACR,QAAS,CACP,eAAgB,mBAChB,cAAe,UAAUrB,CAAW,EACtC,CACF,CACF,EAQA,GANI8C,EAAS,SAAW,MACtB,QAAQ,MAAM,kEAA2D,EACzE,QAAQ,MAAM,iBAAiBA,EAAS,MAAM,EAAE,EAChD,QAAQ,MAAM,MAAMA,EAAS,KAAK,CAAC,GAGjCA,EAAS,SAAW,IACtB,GAAI/C,GAAS,oBAAsBA,GAAS,mBAAqB,EAAG,CAClE,IAAMiD,GAAmBrD,EAAM,IAAI,QAAUI,EAAQ,mBAAqB,GAAKJ,EAAM,IAAI,YACzF,QAAQ,IACN,kEAA2DI,EAAQ,kBAAkB,iBACnFiD,EAAkB,GACpB,MACF,EACA,MAAM,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAe,CAAC,EACnE,MAAMpB,EAAmB5B,EAAaqB,EAAK,CAAE,mBAAoBtB,EAAQ,mBAAqB,CAAE,CAAC,CACnG,KACE,OAAM,IAAI,MAAM,oIAAoI,EAIxJ,OAAI+C,EAAS,QAAU,MACrB,QAAQ,MAAM,wCAAmC,EACjD,QAAQ,MAAM,iBAAiBA,EAAS,MAAM,EAAE,EAChD,QAAQ,MAAM,MAAMA,EAAS,KAAK,CAAC,GAG9BA,EAAS,MAClB,CAQA,eAAsBjB,EAAgB7B,EAAqBqB,EAAa,CACtE,IAAMyB,EAAW,MAAMT,EAAW,8DAA+D,CAC/F,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,cAAe,UAAUrC,CAAW,EACtC,EACA,KAAM,KAAK,UAAU,CACnB,IAAKqB,EACL,KAAM,aACR,CAAC,CACH,CAAC,EAOD,GALIyB,EAAS,SAAW,MACtB,QAAQ,MAAM,kEAA2D,EACzE,QAAQ,MAAM,iBAAiBA,EAAS,MAAM,EAAE,GAG9CA,EAAS,QAAU,IAAK,CAC1B,GAAIA,EAAS,SAAW,IACtB,MAAM,IAAI,MAAM,oIAAoI,EAEpJ,QAAQ,MAAM,oCAA+B,EAC7C,QAAQ,MAAM,iBAAiBA,EAAS,MAAM,EAAE,EAChD,QAAQ,MAAM,MAAMA,EAAS,KAAK,CAAC,CAEvC,CACF,CAtTA,IAAA7D,EAAAF,EAAA,KACAc,IACAV,IACAC","sourcesContent":["export * from \"./auth\";\nexport * from \"./gsc\";\nexport * from \"./sitemap\";\nexport * from \"./types\";\nexport * from \"./utils\";\n","import { getAccessToken } from \"./shared/auth\";\nimport {\n  convertToSiteUrl,\n  getPublishMetadata,\n  requestIndexing,\n  getEmojiForStatus,\n  getPageIndexingStatus,\n  convertToFilePath,\n  checkSiteUrl,\n  checkCustomUrls,\n} from \"./shared/gsc\";\nimport { getSitemapPages } from \"./shared/sitemap\";\nimport { Status } from \"./shared/types\";\nimport { batch } from \"./shared/utils\";\nimport { readFileSync, existsSync, mkdirSync, writeFileSync } from \"fs\";\nimport path from \"path\";\n\nconst CACHE_TIMEOUT = 1000 * 60 * 60 * 24 * 14; // 14 days\nexport const QUOTA = {\n  rpm: {\n    retries: 3,\n    waitingTime: 60000, // 1 minute\n  },\n};\n\nexport type IndexOptions = {\n  client_email?: string;\n  private_key?: string;\n  path?: string;\n  urls?: string[];\n  quota?: {\n    rpmRetry?: boolean; // read requests per minute: retry after waiting time\n  };\n};\n\n/**\n * Indexes the specified domain or site URL.\n * @param input - The domain or site URL to index.\n * @param options - (Optional) Additional options for indexing.\n * @throws Error if there are issues with input parameters or API operations\n */\nexport const index = async (input: string = process.argv[2], options: IndexOptions = {}) => {\n  if (!input) {\n    throw new Error(\"Please provide a domain or site URL as the first argument.\");\n  }\n\n  if (!options.client_email) {\n    options.client_email = process.env.GIS_CLIENT_EMAIL;\n  }\n  if (!options.private_key) {\n    options.private_key = process.env.GIS_PRIVATE_KEY;\n  }\n  if (!options.path) {\n    options.path = process.env.GIS_PATH;\n  }\n  if (!options.urls) {\n    options.urls = process.env.GIS_URLS ? process.env.GIS_URLS.split(\",\") : undefined;\n  }\n  if (!options.quota) {\n    options.quota = {\n      rpmRetry: process.env.GIS_QUOTA_RPM_RETRY === \"true\",\n    };\n  }\n\n  const accessToken = await getAccessToken(options.client_email, options.private_key, options.path);\n  let siteUrl = convertToSiteUrl(input);\n  console.log(`🔎 Processing site: ${siteUrl}`);\n  const cachePath = path.join(\".cache\", `${convertToFilePath(siteUrl)}.json`);\n\n  if (!accessToken) {\n    throw new Error(\"Failed to get access token, check your service account credentials.\");\n  }\n\n  siteUrl = await checkSiteUrl(accessToken, siteUrl);\n\n  let pages = options.urls || [];\n  if (pages.length === 0) {\n    console.log(`🔎 Fetching sitemaps and pages...`);\n    const [sitemaps, pagesFromSitemaps] = await getSitemapPages(accessToken, siteUrl);\n\n    if (sitemaps.length === 0) {\n      throw new Error(\"No sitemaps found, add them to Google Search Console and try again.\");\n    }\n\n    pages = pagesFromSitemaps;\n\n    console.log(`👉 Found ${pages.length} URLs in ${sitemaps.length} sitemap`);\n  } else {\n    pages = checkCustomUrls(siteUrl, pages);\n    console.log(`👉 Found ${pages.length} URLs in the provided list`);\n  }\n\n  const statusPerUrl: Record<string, { status: Status; lastCheckedAt: string }> = existsSync(cachePath)\n    ? JSON.parse(readFileSync(cachePath, \"utf8\"))\n    : {};\n  const pagesPerStatus: Record<Status, string[]> = {\n    [Status.SubmittedAndIndexed]: [],\n    [Status.DuplicateWithoutUserSelectedCanonical]: [],\n    [Status.CrawledCurrentlyNotIndexed]: [],\n    [Status.DiscoveredCurrentlyNotIndexed]: [],\n    [Status.PageWithRedirect]: [],\n    [Status.URLIsUnknownToGoogle]: [],\n    [Status.RateLimited]: [],\n    [Status.Forbidden]: [],\n    [Status.Error]: [],\n  };\n\n  const indexableStatuses = [\n    Status.DiscoveredCurrentlyNotIndexed,\n    Status.CrawledCurrentlyNotIndexed,\n    Status.URLIsUnknownToGoogle,\n    Status.Forbidden,\n    Status.Error,\n    Status.RateLimited,\n  ];\n\n  const shouldRecheck = (status: Status, lastCheckedAt: string) => {\n    const shouldIndexIt = indexableStatuses.includes(status);\n    const isOld = new Date(lastCheckedAt) < new Date(Date.now() - CACHE_TIMEOUT);\n    return shouldIndexIt && isOld;\n  };\n\n  await batch(\n    async (url) => {\n      let result = statusPerUrl[url];\n      if (!result || shouldRecheck(result.status, result.lastCheckedAt)) {\n        const status = await getPageIndexingStatus(accessToken, siteUrl, url);\n        result = { status, lastCheckedAt: new Date().toISOString() };\n        statusPerUrl[url] = result;\n      }\n\n      pagesPerStatus[result.status] = pagesPerStatus[result.status] ? [...pagesPerStatus[result.status], url] : [url];\n    },\n    pages,\n    50,\n    (batchIndex, batchCount) => {\n      console.log(`📦 Batch ${batchIndex + 1} of ${batchCount} complete`);\n    }\n  );\n\n  console.log(``);\n  console.log(`👍 Done, here's the status of all ${pages.length} pages:`);\n  mkdirSync(\".cache\", { recursive: true });\n  writeFileSync(cachePath, JSON.stringify(statusPerUrl, null, 2));\n\n  for (const status of Object.keys(pagesPerStatus)) {\n    const pages = pagesPerStatus[status as Status];\n    if (pages.length === 0) continue;\n    console.log(`• ${getEmojiForStatus(status as Status)} ${status}: ${pages.length} pages`);\n  }\n  console.log(\"\");\n\n  const indexablePages = Object.entries(pagesPerStatus).flatMap(([status, pages]) =>\n    indexableStatuses.includes(status as Status) ? pages : []\n  );\n\n  if (indexablePages.length === 0) {\n    console.log(`✨ There are no pages that can be indexed. Everything is already indexed!`);\n  } else {\n    console.log(`✨ Found ${indexablePages.length} pages that can be indexed.`);\n    indexablePages.forEach((url) => console.log(`• ${url}`));\n  }\n  console.log(``);\n\n  for (const url of indexablePages) {\n    console.log(`📄 Processing url: ${url}`);\n    const status = await getPublishMetadata(accessToken, url, {\n      retriesOnRateLimit: options.quota.rpmRetry ? QUOTA.rpm.retries : 0,\n    });\n    if (status === 404) {\n      await requestIndexing(accessToken, url);\n      console.log(\"🚀 Indexing requested successfully. It may take a few days for Google to process it.\");\n    } else if (status < 400) {\n      console.log(`🕛 Indexing already requested previously. It may take a few days for Google to process it.`);\n    }\n    console.log(``);\n  }\n\n  console.log(`👍 All done!`);\n  console.log(`💖 Brought to you by https://seogets.com - SEO Analytics.`);\n  console.log(``);\n};\n\nexport * from \"./shared\";\n","import { webmasters_v3 } from \"googleapis\";\nimport { QUOTA } from \"..\";\nimport { Status } from \"./types\";\nimport { fetchRetry } from \"./utils\";\n\n/**\n * Converts a given input string to a valid Google Search Console site URL format.\n * @param input - The input string to be converted.\n * @returns The converted site URL (domain.com or https://domain.com/)\n */\nexport function convertToSiteUrl(input: string) {\n  if (input.startsWith(\"http://\") || input.startsWith(\"https://\")) {\n    return input.endsWith(\"/\") ? input : `${input}/`;\n  }\n  return `sc-domain:${input}`;\n}\n\n/**\n * Converts a given file path to a formatted version suitable for use as a file name.\n * @param path - The url to be converted as a file name\n * @returns The converted file path\n */\nexport function convertToFilePath(path: string) {\n  return path.replace(\"http://\", \"http_\").replace(\"https://\", \"https_\").replaceAll(\"/\", \"_\");\n}\n\n/**\n * Converts an HTTP URL to a sc-domain URL format.\n * @param httpUrl The HTTP URL to be converted.\n * @returns The sc-domain formatted URL.\n */\nexport function convertToSCDomain(httpUrl: string) {\n  return `sc-domain:${httpUrl.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \"\")}`;\n}\n\n/**\n * Converts a domain to an HTTP URL.\n * @param domain The domain to be converted.\n * @returns The HTTP URL.\n */\nexport function convertToHTTP(domain: string) {\n  return `http://${domain}/`;\n}\n\n/**\n * Converts a domain to an HTTPS URL.\n * @param domain The domain to be converted.\n * @returns The HTTPS URL.\n */\nexport function convertToHTTPS(domain: string) {\n  return `https://${domain}/`;\n}\n\n/**\n * Retrieves a list of sites associated with the specified service account from the Google Webmasters API.\n * @param accessToken - The access token for authentication.\n * @returns An array containing the site URLs associated with the service account.\n */\nexport async function getSites(accessToken: string) {\n  const sitesResponse = await fetchRetry(\"https://www.googleapis.com/webmasters/v3/sites\", {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n\n  if (sitesResponse.status === 403) {\n    console.error(\"🔐 This service account doesn't have access to any sites.\");\n    return [];\n  }\n\n  const sitesBody: webmasters_v3.Schema$SitesListResponse = await sitesResponse.json();\n\n  if (!sitesBody.siteEntry) {\n    console.error(\"❌ No sites found, add them to Google Search Console and try again.\");\n    return [];\n  }\n\n  return sitesBody.siteEntry.map((x) => x.siteUrl);\n}\n\n/**\n * Checks if the site URL is valid and accessible by the service account.\n * @param accessToken - The access token for authentication.\n * @param siteUrl - The URL of the site to check.\n * @returns The corrected URL if found, otherwise the original site URL.\n * @throws Error if the site URL is invalid or inaccessible\n */\nexport async function checkSiteUrl(accessToken: string, siteUrl: string) {\n  const sites = await getSites(accessToken);\n  let formattedUrls: string[] = [];\n\n  // Convert the site URL into all possible formats\n  if (siteUrl.startsWith(\"https://\")) {\n    formattedUrls.push(siteUrl);\n    formattedUrls.push(convertToHTTP(siteUrl.replace(\"https://\", \"\")));\n    formattedUrls.push(convertToSCDomain(siteUrl));\n  } else if (siteUrl.startsWith(\"http://\")) {\n    formattedUrls.push(siteUrl);\n    formattedUrls.push(convertToHTTPS(siteUrl.replace(\"http://\", \"\")));\n    formattedUrls.push(convertToSCDomain(siteUrl));\n  } else if (siteUrl.startsWith(\"sc-domain:\")) {\n    formattedUrls.push(siteUrl);\n    formattedUrls.push(convertToHTTP(siteUrl.replace(\"sc-domain:\", \"\")));\n    formattedUrls.push(convertToHTTPS(siteUrl.replace(\"sc-domain:\", \"\")));\n  } else {\n    throw new Error(\"Unknown site URL format.\");\n  }\n\n  // Check if any of the formatted URLs are accessible\n  for (const formattedUrl of formattedUrls) {\n    if (sites.includes(formattedUrl)) {\n      return formattedUrl;\n    }\n  }\n\n  // If none of the formatted URLs are accessible\n  throw new Error(\"This service account doesn't have access to this site.\");\n}\n\n/**\n * Checks if the given URLs are valid.\n * @param siteUrl - The URL of the site.\n * @param urls - The URLs to check.\n * @returns An array containing the corrected URLs if found, otherwise the original URLs\n */\nexport function checkCustomUrls(siteUrl: string, urls: string[]) {\n  const protocol = siteUrl.startsWith(\"http://\") ? \"http://\" : \"https://\";\n  const domain = siteUrl.replace(\"https://\", \"\").replace(\"http://\", \"\").replace(\"sc-domain:\", \"\");\n  const formattedUrls: string[] = urls.map((url) => {\n    url = url.trim();\n    if (url.startsWith(\"/\")) {\n      // the url is a relative path (e.g. /about)\n      return `${protocol}${domain}${url}`;\n    } else if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n      // the url is already a full url (e.g. https://domain.com/about)\n      return url;\n    } else if (url.startsWith(domain)) {\n      // the url is a full url without the protocol (e.g. domain.com/about)\n      return `${protocol}${url}`;\n    } else {\n      // the url is a relative path without the leading slash (e.g. about)\n      return `${protocol}${domain}/${url}`;\n    }\n  });\n\n  return formattedUrls;\n}\n\n/**\n * Retrieves the indexing status of a page.\n * @param accessToken - The access token for authentication.\n * @param siteUrl - The URL of the site.\n * @param inspectionUrl - The URL of the page to inspect.\n * @returns A promise resolving to the status of indexing.\n */\nexport async function getPageIndexingStatus(\n  accessToken: string,\n  siteUrl: string,\n  inspectionUrl: string\n): Promise<Status> {\n  try {\n    const response = await fetchRetry(`https://searchconsole.googleapis.com/v1/urlInspection/index:inspect`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        inspectionUrl,\n        siteUrl,\n      }),\n    });\n\n    if (response.status === 403) {\n      console.error(`🔐 This service account doesn't have access to this site.`);\n      console.error(await response.text());\n\n      return Status.Forbidden;\n    }\n\n    if (response.status >= 300) {\n      if (response.status === 429) {\n        return Status.RateLimited;\n      } else {\n        console.error(`❌ Failed to get indexing status.`);\n        console.error(`Response was: ${response.status}`);\n        console.error(await response.text());\n\n        return Status.Error;\n      }\n    }\n\n    const body = await response.json();\n    return body.inspectionResult.indexStatusResult.coverageState;\n  } catch (error) {\n    console.error(`❌ Failed to get indexing status.`);\n    console.error(`Error was: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * Retrieves an emoji representation corresponding to the given status.\n * @param status - The status for which to retrieve the emoji.\n * @returns The emoji representing the status.\n */\nexport function getEmojiForStatus(status: Status) {\n  switch (status) {\n    case Status.SubmittedAndIndexed:\n      return \"✅\";\n    case Status.DuplicateWithoutUserSelectedCanonical:\n      return \"😵\";\n    case Status.CrawledCurrentlyNotIndexed:\n    case Status.DiscoveredCurrentlyNotIndexed:\n      return \"👀\";\n    case Status.PageWithRedirect:\n      return \"🔀\";\n    case Status.URLIsUnknownToGoogle:\n      return \"❓\";\n    case Status.RateLimited:\n      return \"🚦\";\n    default:\n      return \"❌\";\n  }\n}\n\n/**\n * Retrieves metadata for publishing from the given URL.\n * @param accessToken - The access token for authentication.\n * @param url - The URL for which to retrieve metadata.\n * @param options - The options for the request.\n * @returns The status of the request.\n * @throws Error if there are issues with the request or rate limits are exceeded\n */\nexport async function getPublishMetadata(accessToken: string, url: string, options?: { retriesOnRateLimit: number }) {\n  const response = await fetchRetry(\n    `https://indexing.googleapis.com/v3/urlNotifications/metadata?url=${encodeURIComponent(url)}`,\n    {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${accessToken}`,\n      },\n    }\n  );\n\n  if (response.status === 403) {\n    console.error(`🔐 This service account doesn't have access to this site.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n  }\n\n  if (response.status === 429) {\n    if (options?.retriesOnRateLimit && options?.retriesOnRateLimit > 0) {\n      const RPM_WATING_TIME = (QUOTA.rpm.retries - options.retriesOnRateLimit + 1) * QUOTA.rpm.waitingTime; // increase waiting time for each retry\n      console.log(\n        `🚦 Rate limit exceeded for read requests. Retries left: ${options.retriesOnRateLimit}. Waiting for ${\n          RPM_WATING_TIME / 1000\n        }sec.`\n      );\n      await new Promise((resolve) => setTimeout(resolve, RPM_WATING_TIME));\n      await getPublishMetadata(accessToken, url, { retriesOnRateLimit: options.retriesOnRateLimit - 1 });\n    } else {\n      throw new Error(\"Rate limit exceeded, try again later. Check quota at https://developers.google.com/search/apis/indexing-api/v3/quota-pricing#quota\");\n    }\n  }\n\n  if (response.status >= 500) {\n    console.error(`❌ Failed to get publish metadata.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n  }\n\n  return response.status;\n}\n\n/**\n * Requests indexing for the given URL.\n * @param accessToken - The access token for authentication.\n * @param url - The URL to be indexed.\n * @throws Error if there are issues with the request or rate limits are exceeded\n */\nexport async function requestIndexing(accessToken: string, url: string) {\n  const response = await fetchRetry(\"https://indexing.googleapis.com/v3/urlNotifications:publish\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${accessToken}`,\n    },\n    body: JSON.stringify({\n      url: url,\n      type: \"URL_UPDATED\",\n    }),\n  });\n\n  if (response.status === 403) {\n    console.error(`🔐 This service account doesn't have access to this site.`);\n    console.error(`Response was: ${response.status}`);\n  }\n\n  if (response.status >= 300) {\n    if (response.status === 429) {\n      throw new Error(\"Rate limit exceeded, try again later. Check quota at https://developers.google.com/search/apis/indexing-api/v3/quota-pricing#quota\");\n    } else {\n      console.error(`❌ Failed to request indexing.`);\n      console.error(`Response was: ${response.status}`);\n      console.error(await response.text());\n    }\n  }\n}\n"]}